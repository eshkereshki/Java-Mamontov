# Лабараторная работа по Java №1

## Автор
- ФИО: Мамонтов Станислав Игоревич
- Группа: ИТ-9

## Структура
Лабораторные работы состаят из двух основных классов и находится в file1:
1. `Main` - класс с основным методом.
   
2. `Test` - класс, содержащий сигнатуры методов.

# Алгоритм работы заданий

## 1. fraction(double x) - Дробная часть числа

Формулировка:
Дана сигнатура метода: public double fraction (double x);
Необходимо реализовать метод таким образом, чтобы он возвращал только
дробную часть числа х. Подсказка: вещественное число может быть
преобразовано к целому путем отбрасывания дробной части.

Алгоритм:

- Принимает вещественное число x

- Вычитает целую часть: x - (int)x

- Возвращает только дробную составляющую

  Пример: 5.25 → 0.25

## 2. charToNum(char x) - Преобразование символа в число

Формулировка:
Дана сигнатура метода: public int charToNum (char x);
Метод принимает символ х, который представляет собой один из “0 1 2 3 4 5 6 7
8 9”. Необходимо реализовать метод таким образом, чтобы он преобразовывал
символ в соответствующее число. Подсказка: код символа ‘0’ — это число 48.

Алгоритм:

- Принимает символ цифры ('0'-'9')

- Вычитает код символа '0' (48)

- Возвращает числовое значение

  Пример: '3' → 3

## 3. is2Digits(int x) - Проверка двузначности

Формулировка:
Дана сигнатура метода: public bool is2Digits (int x);
Необходимо реализовать метод таким образом, чтобы он принимал число x и
возвращал true, если оно двузначное. 

Алгоритм:

- Проверяет условие: x ≥ 10 AND x ≤ 99

- Возвращает true если число двузначное

  Пример: 25 → true, 5 → false

## 4. isInRange(int a, int b, int num) - Проверка диапазона

Формулировка:
Дана сигнатура метода: public bool isInRange (int a, int b, int num);
Метод принимает левую и правую границу (a и b) некоторого числового
диапазона. Необходимо реализовать метод таким образом, чтобы он возвращал
true, если num входит в указанный диапазон (включая границы). Обратите
внимание, что отношение a и b заранее неизвестно (неясно кто из них больше, а
кто меньше)

Алгоритм:

- Проверяет попадание num в интервал [a, b]

- Возвращает true если a ≤ num ≤ b

  Пример: a=1, b=5, num=3 → true

## 5. isEqual(int a, int b, int c) - Проверка равенства трех чисел

Формулировка:
Дана сигнатура метода: public bool isEqual(int a, int b, int c);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
все три полученных методом числа равны

Алгоритм:

- Проверяет условие: c == a AND c == b

- Возвращает true если все три числа равны

  Пример: 5,5,5 → true; 1,2,3 → false

## 6. abs(int x) - Модуль числа

Формулировка:
Дана сигнатура метода: public int abs (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал модуль
числа х (если оно было положительным, то таким и остается, если он было
отрицательным – то необходимо вернуть его без знака минус).

Алгоритм:

- Если x < 0, возвращает -x

- Иначе возвращает x

  Пример: -5 → 5, 5 → 5

## 7. is35(int x) - Делимость на 3 или 5

Формулировка:
Дана сигнатура метода: public bool is35 (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
число x делится нацело на 3 или 5. При этом, если оно делится и на 3, и на 5, то
вернуть надо false. Подсказка: оператор % позволяет получить остаток от
деления.

Алгоритм:

- Проверяет делимость на 3: x % 3 == 0

- Проверяет делимость на 5: x % 5 == 0

- Возвращает true если делится на 3 ИЛИ на 5, но НЕ на оба

  Пример: 3 → true, 15 → false

## 8. max3(int x, int y, int z) - Максимум из трех чисел

Формулировка:
Дана сигнатура метода: public int max3 (int x, int y, int z);
Необходимо реализовать метод таким образом, чтобы он возвращал
максимальное из трех полученных методом чисел. Подсказка: идеальное
решение включает всего две инструкции if и не содержит вложенных if.

Алгоритм:

- Принимает x как начальный максимум

- Сравнивает с y, обновляет максимум если нужно

- Сравнивает с z, обновляет максимум если нужно

- Возвращает наибольшее число

## 9. sum2(int x, int y) - Сумма с особым условием

Формулировка:
Дана сигнатура метода: public int sum2 (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал сумму
чисел x и y. Однако, если сумма попадает в диапазон от 10 до 19, то надо вернуть
число 20. 

Алгоритм:

- Вычисляет сумму x + y

- Если сумма в диапазоне 10-19, возвращает 20

- Иначе возвращает фактическую сумму

  Пример: 5+7=12 → 20, 8+(-1)=7 → 7

## 10. day(int x) - День недели

Формулировка:
Дана сигнатура метода: public String day (int x);
Метод принимает число x, обозначающее день недели. Необходимо реализовать
метод таким образом, чтобы он возвращал строку, которая будет обозначать
текущий день недели, где 1- это понедельник, а 7 – воскресенье. Если число не
от 1 до 7 то верните текст “это не день недели”. Вместо if в данной задаче
используйте switch. 

Алгоритм:

- Использует switch-case для преобразования чисел 1-7

- Возвращает строковое название дня

- Для неверных значений возвращает сообщение об ошибке

## 11. listNums(int x) - Последовательность чисел

Формулировка:
Дана сигнатура метода: public String listNums (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все числа от 0 до x (включительно).

Алгоритм:

- Цикл от 0 до x включительно

- Конкатенирует числа в строку через пробел

  Пример: x=3 → "0 1 2 3"

## 12. chet(int x) - Четные числа

Формулировка:
Дана сигнатура метода: public String chet (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все четные числа от 0 до x (включительно). Подсказа
для обеспечения качества кода: инструкцию if использовать не следует.

Алгоритм:

- Цикл с шагом 2 от 0 до x

- Использует StringBuilder для эффективности

- Добавляет пробелы между числами

  Пример: x=5 → "0 2 4"

## 13. numLen(long x) - Количество цифр

Формулировка:
Дана сигнатура метода: public int numLen (long x);
Необходимо реализовать метод таким образом, чтобы он возвращал количество
знаков в числе x. 

Алгоритм:

- Обрабатывает особый случай x=0 → 1 цифра

- Берет модуль числа для отрицательных

- Делит число на 10 пока не достигнет 0

- Считает количество итераций

## 14. square(int x) - Квадрат из звездочек

Формулировка:
Дана сигнатура метода: public void square (int x);
Необходимо реализовать метод таким образом, чтобы он выводил на экран
квадрат из символов ‘*’ размером х, у которого х символов в ряд и х символов в
высоту. 

Алгоритм:

- Два вложенных цикла для строк и столбцов

- Выводит x звездочек в каждой строке

- Переходит на новую строку после каждой строки

## 15. rightTriangle(int x) - Правый треугольник

Формулировка:
Дана сигнатура метода: public void rightTriangle (int x);
Необходимо реализовать метод таким образом, чтобы он выводил на экран
треугольник из символов ‘*’ у которого х символов в высоту, а количество
символов в ряду совпадает с номером строки, при этом треугольник выровнен
по правому краю.

Алгоритм:

- Первый цикл: пробелы для выравнивания (x-i пробелов)

- Второй цикл: звездочки (i звездочек)

- Создает эффект выравнивания вправо

## 16. findFirst(int[] arr, int x) - Первое вхождение

Формулировка:
Дана сигнатура метода: public int findFirst (int[] arr, int x);
Необходимо реализовать метод таким образом, чтобы он возвращал индекс
первого вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.

Алгоритм:

- Линейный поиск по массиву

- Возвращает индекс первого совпадения

- Если не найдено → -1

## 17. maxAbs(int[] arr) - Максимум по модулю

Формулировка:
Дана сигнатура метода: public int maxAbs (int[] arr);
Необходимо реализовать метод таким образом, чтобы он возвращал
наибольшее по модулю (то есть без учета знака) значение массива arr.

Алгоритм:

- Находит элемент с наибольшим абсолютным значением

- Использует Math.abs() для сравнения

- Сохраняет оригинальное значение (со знаком)

## 18. add(int[] arr, int[] ins, int pos) - Вставка массива

Формулировка:
Дана сигнатура метода: public int[] add (int[] arr, int[] ins, int pos);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, который будет содержать все элементы массива arr, однако в позицию
pos будут вставлены значения массива ins.


Алгоритм:

- Создает новый массив размером arr.length + ins.length

- Копирует элементы до позиции вставки

- Вставляет элементы ins

- Копирует оставшиеся элементы arr

## 19. reverseBack(int[] arr) - Реверс массива

Формулировка:
Дана сигнатура метода: public int[] reverseBack (int[] arr);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором значения массива arr записаны задом наперед.

Алгоритм:

- Создает массив той же длины

- Записывает элементы в обратном порядке

- arr[i] → result[length-1-i]

## 20. findAll(int[] arr, int x) - Все вхождения

Формулировка:
Дана сигнатура метода: public int[] findAll (int[] arr, int x);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором записаны индексы всех вхождений числа x в массив arr.

Алгоритм:

- Первый проход: подсчет количества совпадений

- Создание массива нужного размера

- Второй проход: запись индексов совпадений




# Лабараторная работа по Java №2 (Вариант 7)

## Автор
- ФИО: Мамонтов Станислав Игоревич
- Группа: ИТ-9

## Структура
Лабораторная работа состоит из семи основных классов и находится в file2:

## 1. `Name` - класс для задания 1.1.

Основной функционал:

- Хранение фамилии, имени и отчества

- Автоматическое форматирование строкового представления

- Игнорирование пустых компонентов при выводе

   
## 2. `Time` - класс для задания 1.2.

Основной функционал:

- Инициализация через количество секунд

- Автоматическая нормализация времени (не более 24 часов)

- Форматирование в строку "ЧЧ:ММ:СС"

## 3. `Employee` - класс для задания 2.

Основной функционал:

- Связь сотрудников с отделами

- Назначение начальников отделов

- Различные текстовые представления в зависимости от роли

## 4. `Employee2` - класс для задания 3.

Основной функционал:

- Статическое хранение всех сотрудников

- Получение списка сотрудников отдела


## 5. `Time2` - класс для задания 4.

Основной функционал:

- Два способа создания: через секунды и через компоненты

- Автоматическая нормализация времени

## 6. `Time3` - класс для задания 5.

Основной функционал:

- Получение отдельных компонентов времени

- Геттеры для часов, минут и секунд

- Использование геттеров в `toString()`

## 7. `Main` - класс для запуска.

Основной функционал:

- Единая точка входа для всех программ

- Интерактивное меню выбора

- Дружественный пользовательский интерфейс

## Структура проекта

```
project/
├── Name.java
├── Time.java
├── Time2.java
├── Time3.java
├── Employee.java
├── Employee2.java
└── Main.java
```

# Алгоритм работы заданий

## Задача 1.1: Имена (Name.java)

Формулировка:
Создайте сущность Имя, которая описывается тремя параметрами: Фамилия, Личное имя,
Отчество. Имя может быть приведено к строковому виду, включающему традиционное
представление всех трех параметров: Фамилия Имя Отчество (например “Иванов Иван
Иванович”). Необходимо предусмотреть возможность того, что какой-либо из параметров может
быть не задан, и в этом случае он не учитывается при приведении к текстовому виду.
Необходимо создать следующие имена:

- Клеопатра

- Пушкин Александр Сергеевич

- Маяковский Владимир

Обратите внимание, что при выводе на экран, не заданные параметры никак не участвуют в
образовании строки.

Алгоритм:

1. **Инициализация объекта**

   - Создание объекта Name с тремя параметрами (фамилия, имя, отчество)

   - Любой параметр может быть `null` или пустой строкой

2.  **Форматирование вывода**

   - Проверка наличия фамилии - добавление если не пустая

   - Проверка наличия имени - добавление с пробелом если не пустое

   - Проверка наличия отчества - добавление с пробелом если не пустое

   - Возврат отформатированной строки

3.  **Тестирование трех вариантов имен**

     Только имя ("Клеопатра")

     Полное ФИО ("Пушкин Александр Сергеевич")

     Без отчества ("Маяковский Владимир")

## Задача 1.2: Время (Time.java)

Формулировка:
Создайте сущность Время, которое будет описывать текущее время суток в 24-х часовом
формате. Время описывается числом секунд, прошедшим с начала суток. Время может быть
приведено к текстовой форме следующего формата: “ЧЧ:ММ:СС”. Например,если время задано как
12000, то текстовая форма будет “3:20:00”. Если общее время превышает 24 часа, то отображаться
в текстовом виде должно только то время, которое прошло с начала последних суток, например
91800, это не 25:30:00, а 1:30:00.

Необходимо создать и вывести на экран текстовую форму для следующих вариантов времени:

- 10 секунд

- 10000 секунд

- 100000 секунд

Алгоритм:

1. **Инициализация**

   - Создание объекта Time с количеством секунд
   
   -  Сохранение значения в приватном поле

2. **Нормализация времени**

   - Вычисление `totalSeconds = seconds % 86400` (секунд в сутках)

   - Обеспечение корректного отображения времени >24 часов

3. **Разделение на компоненты**

   - Часы: `totalSeconds / 3600`

   - Минуты: `(totalSeconds % 3600) / 60`

   - Секунды: `totalSeconds % 60`

4. **Форматирование**

   - Сборка строки в формате "ЧЧ:ММ:СС"

   - Добавление ведущих нулей для минут и секунд

5. **Тестирование**

   10 сек, 10000 сек, 100000 сек

## Задача 2: Сотрудники и отделы (Employee.java)

Формулировка:
Создайте сущность Сотрудник, которая описывается именем (в строковой форме) и отделом, в
котором сотрудник работает, причем у каждого отдела есть название и начальник, который
также является Сотрудником. Сотрудник может быть приведен к текстовой форме вида: “Имя
работает в отделе Название, начальник которого Имя”. В случае если сотрудник является
руководителем отдела, то текстовая форма должна быть “Имя начальник отдела Название”.
Необходимо выполнить следующие задачи:

1. Создать Сотрудников Петрова, Козлова, Сидорова работающих в отделе IT.

2. Сделать Козлова начальником IT отдела.

3. Вывести на экран текстовое представление всех трех Сотрудников (у всех троих должен
оказаться один и тот же отдел и начальник).

Алгоритм:

1. **Создание структуры**

   - Создание сотрудников с именем и отделом

   - Установка флага `isBoss = false` по умолчанию

3. **Назначение начальника**

   - Вызов `setBoss()` для подчиненных

   - Установка ссылки на начальника

    - Автоматическая установка `isBoss = true` для начальника

5. **Интеллектуальный вывод**

   - Проверка роли сотрудника

   - Разные форматы для начальников и подчиненных

    - Обработка случая без начальника

6. **Тестирование**

   Петров, Козлов (начальник), Сидоров в IT отделе

## Задача 3: Сотрудники и отделы (расширение) (Employee2.java)

Формулировка:
Измените решение, полученное в задаче 2.4 таким образом, чтобы имея ссылку на сотрудника,
можно было бы узнать список всех сотрудников этого отдела.

Алгоритм:

1. **Статическое хранение**

   - Статический список `allEmployees`

   - Автоматическое добавление при создании объекта

   - Очистка списка перед демонстрацией

3. **Получение сотрудников отдела**

   - Перебор всех сотрудников в `allEmployees`

   - Фильтрация по названию отдела

   - Возврат списка сотрудников отдела

5. **Демонстрация функциональности**

   - Создание сотрудников и назначение начальника

   - Вывод информации о сотрудниках

   - Вывод списка всех сотрудников отдела

## Задача 4: Время (расширение) (Time2.java)

Формулировка:
Измените сущность Время из задачи 1.4. Новые требования включают:

- Время можно создать указав количество секунд с начала суток

- Время можно создать указав количество часов, минут, секунд текущего времени.

- Гарантируйте, что операция присвоения в инициализаторах будет использована не более
одного раза

Необходимо создать и вывести на экран текстовую форму для следующих вариантов времени:

1. 10000 секунд

2. 2 часа, 3 минуты, 5 секунд

Алгоритм:

1. **Конструктор через секунды**
   - Принимает общее количество секунд
   - Нормализует: `seconds % 86400`
   - Однократное присвоение поля

2. **Конструктор через компоненты**
   - Принимает часы, минуты, секунды
   - Вычисляет общее количество секунд
   - Нормализует результат
   - Однократное присвоение поля

3. **Преобразование в строку**
   - Аналогично классу Time
   - Использует нормализованное значение секунд

4. **Тестирование**
    10000 сек и 2ч 3м 5с

## Задача 5: Время (расширение 2) (Time3.java)

Формулировка:
Измените сущность Время из задачи 4.4.Добавьте ей возможность возвращать следующие сведения:

- Какой сейчас час (целое число)

- Сколько минут прошло с начала текущего часа (целое число)

- Сколько секунд прошло с начала текущей минуты (целое число)

Необходимо выполнить следующие задачи:

1. Вывести на экран сколько часов соответствуют времени 34056

2. Вывести на экран сколько минут соответствуют времени 4532

3. Вывести на экран сколько секунд соответствуют времени 123


Алгоритм:

1. **Инициализация**

   - Создание объекта через секунды

   - Нормализация времени

3. **Методы доступа к компонентам**

   - `getHours()`: возвращает `seconds / 3600`

   - `getMinutes()`: возвращает `(seconds % 3600) / 60`

   - `getSecs()`: возвращает `seconds % 60`

5. **Обновленный toString()**

   - Использует геттеры вместо прямых вычислений

   - Обеспечивает согласованность данных

6. **Тестирование**

   Часы для 34056 сек

   Минуты для 4532 сек

   Секунды для 123 сек

# Лабораторная работа по Java №3 (Вариант 7)

## Автор
- ФИО: Мамонтов Станислав Игоревич
- Группа: ИТ-9

## Структура
Лабораторная работа выполнена в виде одного проекта и разделена на пакеты,
каждый из которых соответствует отдельному заданию.

---

## 1. `Point` — точка на плоскости

### Формулировка задания  
Создать сущность Точка, расположенную на двумерной плоскости, которая описывается
координатами X и Y и может возвращать своё текстовое представление вида `(X;Y)`.
Необходимо создать несколько точек и вывести их на экран.

### Алгоритм решения

1. Создать класс `Point` с полями `x` и `y`
2. Реализовать конструктор для инициализации координат
3. Переопределить метод `toString()`
4. Создать несколько объектов и вывести их представление

---

## 2. `Point3D` — трёхмерная точка

### Формулировка задания  
Создать подкласс сущности Точка, который будет иметь три координаты: X, Y, Z.

### Алгоритм решения

1. Создать класс `Point3D`, наследующий `Point`
2. Добавить координату `z`
3. Вызвать конструктор родителя через `super`
4. Переопределить `toString()` для вывода трёх координат

---

## 3. `PointComp` — сравнение точек

### Формулировка задания  
Переопределить метод сравнения объектов таким образом, чтобы две точки считались
одинаковыми, если они расположены в одинаковых координатах.

### Алгоритм решения

1. Переопределить метод `equals(Object obj)`
2. Проверить тип сравниваемого объекта
3. Сравнить координаты X и Y
4. Переопределить `hashCode()`
5. Продемонстрировать сравнение точек

---

## 4. `BinTree` — бинарное дерево

### Формулировка задания  
Реализовать структуру данных «бинарное дерево» с возможностью добавления,
удаления, поиска и вывода элементов.

### Алгоритм решения

1. Создать класс `BinTree`
2. Реализовать внутренний класс `Node`
3. Добавить метод вставки значения
4. Реализовать поиск элемента
5. Реализовать удаление элемента
6. Реализовать вывод всех элементов дерева

---

## 5. `Bird` и наследники — птицы

### Формулировка задания  
Создать базовый класс Птица и несколько подклассов с разным поведением пения.

### Алгоритм решения

1. Создать абстрактный класс `Bird`
2. Определить метод `sing()`
3. Создать классы `Sparrow`, `Chicken`, `Parrot`
4. Переопределить метод `sing()` в каждом классе
5. Для попугая реализовать случайный вывод символа

---

## 6. `BirdMarket` — птичий рынок

### Формулировка задания  
Создать метод, который принимает набор птиц и вызывает у каждой метод пения.

### Алгоритм решения

1. Создать класс `BirdMarket`
2. Реализовать метод, принимающий массив или список птиц
3. Использовать полиморфизм
4. Продемонстрировать работу метода

---

## 7. `Employee3` — сотрудники и отделы

### Формулировка задания  
Создать сущности Сотрудник и Отдел. Гарантировать, что начальник работает в том же
отделе, которым он руководит.

### Алгоритм решения

1. Создать класс сотрудника с именем и отделом
2. Реализовать назначение начальника
3. Проверить принадлежность к одному отделу
4. Реализовать корректное текстовое представление
5. Продемонстрировать работу

---

## 8. `EmployeeTrust` — отделы доверяют начальникам

### Формулировка задания  
Упростить решение, обеспечив корректность связей за счёт инкапсуляции на уровне пакета.

### Алгоритм решения

1. Ограничить доступ к конструкторам и полям
2. Связать отдел и сотрудников архитектурно
3. Исключить необходимость проверок
4. Продемонстрировать корректную работу

---

## 9. `Power` — возведение в степень

### Формулировка задания  
Создать метод, принимающий две строки X и Y, преобразующий их в числа и
возвращающий результат X в степени Y.

### Алгоритм решения

1. Принять аргументы командной строки
2. Преобразовать строки в числа (`Integer.parseInt`)
3. Возвести в степень (`Math.pow`)
4. Вывести результат
5. Обработать ошибку отсутствия аргументов

---

## 10. `Main` — главный класс

### Формулировка задания  
Создать единый класс с методом `main`, который запускает все задания лабораторной
работы через меню.

### Алгоритм решения

1. Создать консольное меню
2. Реализовать выбор задания
3. Вызвать демонстрационные методы
4. Обеспечить удобный пользовательский интерфейс

---

## Структура проекта
```
src/
└── Mamontov/App/
├── Birds/
│ ├── Bird.java
│ ├── BirdDemo.java
│ ├── BirdMarket.java
│ ├── BirdMarketDemo.java
│ ├── Chicken.java
│ ├── Parrot.java
│ └── Sparrow.java
│
├── Employee/
│ ├── Department.java
│ ├── Employee3.java
│ └── EmployeeTrust.java
│
├── geometry/
│ ├── Point.java
│ ├── Point3D.java
│ └── PointComp.java
│
├── Main/
│ └── Main.java
│
├── Math/
│ └── Power.java
│
├── Time/
│ └── Time4.java
│
└── Tree/
└── BinTree.java
```
